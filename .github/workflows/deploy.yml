name: CI/CD to EC2 (Docker)

on:
  push:
    branches: [ main ]   # 배포 트리거 브랜치(원하면 dev/staging으로 변경)
  workflow_dispatch:      # 수동 실행 버튼

env:
  IMAGE_NAME: saycando/myapp
  CONTAINER_NAME: myapp
  ENV_PATH: /home/ubuntu/app/.env
  APP_PORT: "8080"

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx   # ← 추가!
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          driver: docker-container
          
      # Docker Hub 로그인
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 캐시 사용해 도커 빌드 & 푸시 (latest + sha)
      - name: Build and Push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH key
        run: |
          echo "${{ secrets.EC2_SSH_KEY }}" > key.pem
          chmod 600 key.pem

      - name: Add host to known_hosts
        run: |
          ssh-keyscan -H "${{ secrets.EC2_HOST }}" >> ~/.ssh/known_hosts

      - name: Deploy on EC2 (pull & restart container)
        run: |
          ssh -i key.pem -o StrictHostKeyChecking=yes ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'EOF'
            set -e

            # 1) Docker 로그인(레포가 프라이빗이면 필요, 퍼블릭이면 생략 가능)
            echo "${DOCKERHUB_TOKEN}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin || true

            # 2) 최신 이미지 받기
            docker pull ${IMAGE_NAME}:latest

            # 3) 기존 컨테이너 교체(다운타임 최소화 원하면 블루/그린으로 확장 가능)
            docker stop ${CONTAINER_NAME} || true
            docker rm   ${CONTAINER_NAME} || true
            docker image prune -f || true

            # 4) 재기동: 127.0.0.1:8080 로컬 바인딩 (Nginx가 프록시)
            docker run -d --name ${CONTAINER_NAME} \
              --restart unless-stopped \
              -p 127.0.0.1:${APP_PORT}:8080 \
              --env-file ${ENV_PATH} \
              ${IMAGE_NAME}:latest

            # 5) 상태 점검
            sleep 2
            curl -s -I http://127.0.0.1:${APP_PORT} || true
          EOF
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          ENV_PATH: ${{ env.ENV_PATH }}
          APP_PORT: ${{ env.APP_PORT }}
